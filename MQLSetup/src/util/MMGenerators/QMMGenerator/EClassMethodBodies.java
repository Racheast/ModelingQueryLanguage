package util.MMGenerators.QMMGenerator;

import java.util.Map;

import org.eclipse.emf.common.util.DiagnosticChain;
import org.eclipse.emf.ecore.EClass;

public class EClassMethodBodies {
	public static final String ROOTCLASS_VALIDATIONOPERATION_BODY = "if(diagnostic!=null){"
			+ "\n    if(this.evaluationOperator != null){"
			//+ "\n    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.evaluationOperator);"  //commented out on 8.12.18: trying to reintroduce multiple eval: operations per rootclass
			+ "\n    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateAllCheckExpressions(this.evaluationOperator);"
			+ "\n    	for(int i=0; i<diagnosticList.size(); i++){"
			+ "\n    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));"
			+ "\n    	}"
			+ "\n    }"
			+ "\n}";
	
	//Added on 8.12.18: trying to reintroduce multiple eval: expressions
	public static final String ROOTCLASS_VALIDATEALLCHECKEXPRESSIONS_BODY = "\n	EList<qmm.Operator> operators = (EList<qmm.Operator>)o;"
			+ "\n	EList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n	if(operators != null){"
			+ "\n		for(qmm.Operator operator:operators){"
			+ "\n			diagnosticList.addAll(validateCheckExpression(operator));"
			+ "\n		}"
			+ "\n   }"
			+ "\n	return diagnosticList;";
	
	public static final String ROOTCLASS_VALIDATECHECKEXPRESSION_BODY = "EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();"  
			+ "\nEClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();"
			+ "\nEClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();"
			+ "\nqmm.Operator operator = (qmm.Operator)o;"
			+ "\nEList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n"
			+ "\nif(functionalOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();"
			+ "\n    	EClass lastOperatorType = (EClass)lastOperator.getType();"
			+ "\n    	if(!booleanType.isSuperTypeOf(lastOperatorType)){"
			+ "\n			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";"
			+ "\n    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ "\n    	}"	
			+ "\n}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){"
			+ "\n    	diagnosticList.addAll(validateCheckExpression(op));"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn diagnosticList;";
	
	public static final String REGULAR_ATTRIBUTE_ECLASS_VALIDATECHECKEXPRESSION_BODY = "EClass booleanType = QmmPackage.eINSTANCE.getBoolean_Type();"  
			+ "\nEClass functionalOperatorType = QmmPackage.eINSTANCE.getFunctionalOperator();"
			+ "\nEClass bitOperatorType = QmmPackage.eINSTANCE.getBitOperator();"
			+ "\nqmm.Operator operator = (qmm.Operator)o;"
			+ "\nEList diagnosticList = new org.eclipse.emf.common.util.BasicEList();"
			+ "\n"
			+ "\nif(functionalOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n	qmm.FunctionalOperator lastOperator = (qmm.FunctionalOperator)((qmm.FunctionalOperator)operator).getLastOperator();"
			+ "\n    	EClass lastOperatorType = (EClass)lastOperator.getType();"
			+ "\n    	if(!booleanType.isSuperTypeOf(lastOperatorType)){"
			+ "\n			String errorMessage = \"Operator \" + lastOperator.eClass().getName() + \" of attribute \" + this.eClass().getName() + \" is of type \" + lastOperatorType.getName() + \", but must be (a subtype) of type \" + booleanType.getName() + \".\";"
			+ "\n    		diagnosticList.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ "\n    	}"	
			+ "\n}else if(bitOperatorType.isSuperTypeOf(operator.eClass())){"
			+ "\n    for(qmm.Operator op : (EList<qmm.Operator>)operator.eGet(operator.eClass().getEStructuralFeature(\"connects\"))){"
			+ "\n    	diagnosticList.addAll(validateCheckExpression(op));"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn diagnosticList;";
	
	public static final String TYPED_CALCULATEABLE_ELEMENT_REFERENCE_ARGUMENT_VALIDATIONOPERATION_BODY = "qmm.RootClass containingRootClass = null;"
			+ 	"\nqmm.RootClass referencesRootClass = null;"
			+ 	"\nqmm.AttributeEClass containingAttributeEClass = null;"
			+ 	"\nqmm.AttributeEClass referencesAttributeEClass = null;"
			+	"\nif(this.eContainer() != null && this.reference != null){"
			+ 	"\n		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();"
			+ 	"\n"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			if(eContainer instanceof qmm.AttributeEClass){"
			+ 	"\n				containingAttributeEClass = (qmm.AttributeEClass)eContainer;"
			+ 	"\n			}"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n		containingRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"
			+ 	"\n		eContainer = this.reference.eContainer();"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n"
			+ 	"\n		referencesRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n		if(this.reference instanceof qmm.AttributeEClass) referencesAttributeEClass = (qmm.AttributeEClass)this.reference;"
			+ 	"\n"
			+ 	"\n		if(containingAttributeEClass != null && referencesAttributeEClass != null && containingAttributeEClass == referencesAttributeEClass){  //self-reference in expression !"
			+ 	"\n			String errorMessage = \"Self-reference in expression of attribute \" + containingAttributeEClass.getName() + \" detected. Self-references are not allowed!\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+	"\n"
			+ 	"\n		if(containingRootClass != referencesRootClass){"
			+ 	"\n			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+	"\n"
			+	"\n		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));"
			+	"\n"
			+	"\n}"
			+ 	"\nreturn true;";
	
	public static final String TYPED_REGULAR_ATTRIBUTE_ECLASS_VALIDATIONOPERATION_BODY = "if(diagnostic!=null){"
			+ "\n    if(this.operator != null){"
			+ "\n    	EList<org.eclipse.emf.common.util.BasicDiagnostic> diagnosticList = validateCheckExpression(this.operator);"
			+ "\n    	for(int i=0; i<diagnosticList.size(); i++){"
			+ "\n    		diagnostic.add((org.eclipse.emf.common.util.BasicDiagnostic)diagnosticList.get(i));"
			+ "\n    	}"
			+ "\n    }"
			+ "\n}"
			+ "\nreturn true;";
	
	public static final String TYPED_ELEMENT_GETTYPE_BODY  = "EClass typeEClass = QmmPackage.eINSTANCE.getType();"
			+ "\n    EClass type = null;"
			+ "\n    for(EClass possibleTypeSubClass : this.eClass().getEAllSuperTypes()){"
			+ "\n    	if(typeEClass.isSuperTypeOf(possibleTypeSubClass) && !typeEClass.equals(possibleTypeSubClass)){"
			+ "\n    		type = possibleTypeSubClass;"
			+ "\n    	}"
			+ "\n    }"
			+ "\n    return type;";
	
	public static final String FUNCTIONAL_OPERATOR_GETLASTOPERATOR_BODY = "qmm.FunctionalOperator operator = this;"
			+ "\nwhile(operator.eGet(operator.eClass().getEStructuralFeature(\"operator\")) != null){"
			+ "\n    operator = (qmm.FunctionalOperator) operator.eGet(operator.eClass().getEStructuralFeature(\"operator\"));"
			+ "\n}"
			+ "\nreturn operator;";
	
	public static final String COUNTABLE_REFERENCE_ARGUMENT_VALIDATIONOPERATION_BODY = "qmm.RootClass containingRootClass = null;"
			+ 	"\nqmm.RootClass referencesRootClass = null;"
			+ 	"\nqmm.Countable containingCountable = null;"
			+ 	"\n"
			+	"\nif(this.eContainer() != null && this.reference != null){"
			+ 	"\n		org.eclipse.emf.ecore.EObject eContainer = this.eContainer();"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			if(eContainer instanceof qmm.Countable){"
			+ 	"\n				containingCountable = (qmm.Countable)eContainer;"
			+ 	"\n			}"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n		containingRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"
			+ 	"\n		eContainer = this.reference.eContainer();"
			+ 	"\n		while(eContainer != null && !(eContainer instanceof qmm.RootClass)){"
			+ 	"\n			eContainer = eContainer.eContainer();"
			+ 	"\n		}"
			+ 	"\n"
			+ 	"\n		referencesRootClass = (qmm.RootClass)eContainer;"
			+ 	"\n"
			+ 	"\n		if(containingCountable != null && containingCountable == reference){  //self-reference in expression !"
			+ 	"\n			String errorMessage = \"Self-reference in expression of \" + containingCountable + \" detected. Self-references are not allowed!\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+ 	"\n"
			+ 	"\n		if(containingRootClass != referencesRootClass){"
			+ 	"\n			String errorMessage = \"The referenced element \" + this.reference + \" is contained by a different parent-element than the expression's parent-element. Cross-references are not supported.\";"
			+ 	"\n			diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, errorMessage,new Object[] { this }));"
			+ 	"\n		}"
			+	"\n"
			+	"\n		if(this.reference instanceof qmm.NegatableElement && ((qmm.NegatableElement)this.reference).isNegated())diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OBJECT_FUNCTIONAL_PARAMETER__VALIDATE, \"Reference to a negated element in \" + this + \" has been detected. References to negated elements are not allowed.\",new Object[] { this }));"
			+	"\n}"
			+	"\n"
			+ 	"\nreturn true;";
	
	public static final String ORGROUP_VALIDATIONOPERATION_BODY 	=	"EClass containerEClass = this.eContainingFeature().getEContainingClass();"
																	+	"org.eclipse.emf.ecore.EClassifier eType = this.eClass().getEStructuralFeature(\"containment\").getEType();"
																	+	"if(eType != null && eType instanceof EClass){"
																	+	"	EClass typeEClass = (EClass)eType;"
																	+	"	if(!containerEClass.isSuperTypeOf(typeEClass) && this.transitive){"
																	+	"		String errorMessage = \"Feature \" + this.name + \" can't be transitive! It is defined by the type \" + containerEClass.getName() + \", but is itself not an instance of (a subtype of) this type.\";"
																	+	"		diagnostic.add(new org.eclipse.emf.common.util.BasicDiagnostic(org.eclipse.emf.common.util.Diagnostic.ERROR, qmm.util.QmmValidator.DIAGNOSTIC_SOURCE,qmm.util.QmmValidator.OR_GROUP__VALIDATE, errorMessage,new Object[] { this }));"
																	+	"	}"
																	+	"}"
																	+	"return true;";
}
